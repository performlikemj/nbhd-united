"""Journal-domain helper services for templates and note persistence."""
from __future__ import annotations

from copy import deepcopy
from datetime import date
import re

from django.core.exceptions import ValidationError
from django.utils import timezone as tz

from .models import DailyNote, NoteTemplate


DEFAULT_TEMPLATE_SLUG = "default"
DEFAULT_TEMPLATE_NAME = "Default"

DEFAULT_TEMPLATE_SECTIONS: list[dict[str, str]] = [
    {
        "slug": "morning-report",
        "title": "Morning Report",
        "content": "*Generated by your agent each morning.*",
        "source": "agent",
    },
    {
        "slug": "weather",
        "title": "Weather",
        "content": "",
        "source": "agent",
    },
    {
        "slug": "news",
        "title": "News",
        "content": "",
        "source": "agent",
    },
    {
        "slug": "focus",
        "title": "Focus",
        "content": "",
        "source": "agent",
    },
    {
        "slug": "evening-check-in",
        "title": "Evening Check-in",
        "content": "*Fill this in at the end of your day.*",
        "source": "human",
    },
]

# Old 3-section defaults — used to detect unmodified templates during seeding.
_OLD_DEFAULT_SLUGS = {"morning-report", "log", "evening-check-in"}

_ENTRY_SECTION_HEADER_RE = re.compile(r"^\d{1,2}:\d{2}\b")
_LEGACY_ENTRY_HEADER_RE = re.compile(r"^##\s+\d{1,2}:\d{2}\b")


def _validate_template_sections(sections: list[dict], /) -> list[dict[str, str]]:
    if not isinstance(sections, list):
        raise ValidationError("sections must be an array.")
    if len(sections) == 0:
        raise ValidationError("sections cannot be empty.")

    seen_slugs: set[str] = set()
    normalised: list[dict[str, str]] = []
    for index, section in enumerate(sections):
        if not isinstance(section, dict):
            raise ValidationError(f"section index={index} must be an object")

        slug = str(section.get("slug") or "").strip()
        title = str(section.get("title") or "").strip()
        content = str(section.get("content") or "").strip()
        source = str(section.get("source") or "shared").strip()

        if not slug:
            raise ValidationError(f"section index={index} is missing slug")
        if not title:
            raise ValidationError(f"section index={index} is missing title")
        if slug in seen_slugs:
            raise ValidationError(f"duplicate section slug: {slug}")
        if source not in {choice[0] for choice in NoteTemplate.Source.choices}:
            raise ValidationError(f"section index={index} has invalid source: {source}")

        seen_slugs.add(slug)
        normalised.append(
            {
                "slug": slug,
                "title": title,
                "content": content,
                "source": source,
            }
        )

    return normalised


def _default_template_payload() -> list[dict[str, str]]:
    return deepcopy(DEFAULT_TEMPLATE_SECTIONS)


def seed_default_templates_for_tenant(*, tenant, dry_run: bool = False):
    """Ensure the tenant has a default note template."""
    template_defaults = {
        "name": DEFAULT_TEMPLATE_NAME,
        "sections": _default_template_payload(),
        "is_default": True,
        "source": NoteTemplate.Source.SHARED,
    }

    if dry_run:
        return {
            "created": not NoteTemplate.objects.filter(tenant=tenant, slug=DEFAULT_TEMPLATE_SLUG).exists(),
            "template": None,
        }

    template, created = NoteTemplate.objects.get_or_create(
        tenant=tenant,
        slug=DEFAULT_TEMPLATE_SLUG,
        defaults=template_defaults,
    )

    if not created:
        template.is_default = True
        # Only overwrite sections if they still match the old 3-section defaults.
        existing_slugs = {s.get("slug") for s in (template.sections or [])}
        if existing_slugs == _OLD_DEFAULT_SLUGS:
            template.sections = template_defaults["sections"]
        template.source = NoteTemplate.Source.SHARED
        template.save(update_fields=["is_default", "sections", "source"])

    return {"created": created, "template": template}


def get_default_template(*, tenant):
    template = NoteTemplate.objects.filter(tenant=tenant, is_default=True).order_by("-updated_at").first()
    if template is not None:
        return template
    template = NoteTemplate.objects.filter(tenant=tenant).order_by("-created_at").first()
    if template is not None:
        return template
    return None


def ensure_daily_note_template(*, tenant, note):
    template = get_default_template(tenant=tenant)
    if template is None:
        seeded = seed_default_templates_for_tenant(tenant=tenant)
        template = seeded["template"]
    if note.template_id != getattr(template, "id", None):
        note.template = template
        note.save(update_fields=["template"])
    return template


def parse_daily_sections(markdown: str | None) -> list[dict[str, str]]:
    if not markdown:
        return []

    lines = markdown.splitlines()
    sections: list[dict[str, str]] = []
    current_title: str | None = None
    current_slug: str | None = None
    current_lines: list[str] = []
    current_is_entry = False

    def _flush() -> None:
        nonlocal sections, current_title, current_slug, current_lines
        if current_title is None:
            return
        sections.append(
            {
                "title": current_title,
                "slug": current_slug or "section",
                "content": "\n".join(current_lines).strip(),
            }
        )

    for raw in lines:
        line = raw.strip()
        if line.startswith("# ") and not line.startswith("## "):
            continue
        if line.startswith("## "):
            _flush()
            current_title = line[3:].strip()
            if not current_title:
                current_title = "Section"
            if _ENTRY_SECTION_HEADER_RE.match(current_title):
                current_title = None
                current_lines = []
                current_is_entry = True
                continue
            if not current_title:
                current_slug = "section"
            else:
                current_slug = current_title.lower().replace(" ", "-")
            current_lines = []
            current_is_entry = False
            continue
        if current_title is not None and not current_is_entry:
            current_lines.append(raw)

    _flush()
    return [section for section in sections if section["title"] or section["content"]]


def materialize_sections_markdown(*, note_date: date, sections: list[dict], template_name: str | None = None):
    heading_prefix = f"# {note_date}"
    if template_name:
        heading_prefix = f"# {note_date} ({template_name})"

    lines = [heading_prefix]
    for section in sections:
        title = section.get("title") or section.get("slug") or "Section"
        content = section.get("content", "")
        lines.append("")
        lines.append(f"## {title}")
        if content:
            lines.append(content)

    return "\n".join(lines) + "\n"


def get_or_seed_note_template(*, tenant, date_value: date, markdown: str | None = None) -> tuple[NoteTemplate, list[dict]]:
    """Load template for a tenant's daily note and initialise sections from markdown if available."""
    template = get_default_template(tenant=tenant)
    if template is None:
        template = seed_default_templates_for_tenant(tenant=tenant)["template"]

    source_sections = parse_daily_sections(markdown or "")
    if source_sections:
        return template, source_sections

    # Preserve legacy notes that still contain entry-style headers (e.g. ## 09:00 — MJ)
    # by seeding a sectionized payload from template defaults with legacy content
    # stored in the "log" section.
    markdown_value = (markdown or "").strip()
    if markdown_value:
        default_sections = deepcopy(template.sections)
        has_legacy_entries = any(
            _LEGACY_ENTRY_HEADER_RE.match(line.strip()) for line in markdown_value.splitlines()
        )
        if has_legacy_entries:
            for section in default_sections:
                if section.get("slug") == "log":
                    existing_content = section.get("content", "")
                    merged_content = []
                    if markdown_value:
                        merged_content.append(markdown_value)
                    if existing_content:
                        merged_content.append(existing_content)
                    section["content"] = "\n\n".join(merged_content)
                    break
            return template, default_sections
    return template, deepcopy(template.sections)


def set_daily_note_section(
    *,
    note: DailyNote,
    section_slug: str,
    content: str,
) -> tuple[DailyNote, list[dict[str, str]]]:
    """Update a single section's content in the rendered note."""
    template, sections = get_or_seed_note_template(
        tenant=note.tenant,
        date_value=note.date,
        markdown=note.markdown,
    )

    section_slug = section_slug.strip()
    updated = False
    for section in sections:
        if section["slug"] == section_slug:
            section["content"] = content.strip()
            updated = True
            break

    if not updated:
        # Auto-create the section. Insert before evening-check-in if present.
        new_section = {
            "slug": section_slug,
            "title": section_slug.replace("-", " ").title(),
            "content": content.strip(),
        }
        evening_idx = next(
            (i for i, s in enumerate(sections) if s["slug"] == "evening-check-in"),
            None,
        )
        if evening_idx is not None:
            sections.insert(evening_idx, new_section)
        else:
            sections.append(new_section)

    note = set_daily_note_sections(note=note, sections=sections, template=template)
    return note, sections


def set_daily_note_sections(*, note: DailyNote, sections: list[dict], template: NoteTemplate | None = None) -> DailyNote:
    if not sections:
        raise ValidationError("sections cannot be empty.")

    if template is not None:
        note.template = template

    section_payload: list[dict[str, str]] = []
    for section in sections:
        slug = str(section.get("slug") or "").strip()
        title = str(section.get("title") or "").strip()
        content = str(section.get("content") or "").strip()
        if not slug:
            raise ValidationError("section slug is required")
        if not title:
            raise ValidationError("section title is required")
        section_payload.append(
            {
                "slug": slug,
                "title": title,
                "content": content,
            }
        )

    note.markdown = materialize_sections_markdown(
        note_date=note.date,
        sections=section_payload,
        template_name=template.name if template is not None else None,
    )
    note.save(update_fields=["markdown", "template", "updated_at"])
    return note


def append_log_to_note(
    *,
    note: DailyNote,
    content: str,
    author: str = "agent",
    time_str: str | None = None,
) -> DailyNote:
    """Append a timestamped log entry to the daily note.

    If the note has a section with slug 'log', appends within it.
    Otherwise appends to the tail of the markdown document.
    """
    if not time_str:
        time_str = tz.now().strftime("%H:%M")

    author_label = "Agent" if author == "agent" else "MJ"
    entry_block = f"\n\n### {time_str} \u2014 {author_label}\n{content.strip()}\n"

    # Check if there is a log section we can append within.
    _, sections = get_or_seed_note_template(
        tenant=note.tenant,
        date_value=note.date,
        markdown=note.markdown,
    )
    log_section = next((s for s in sections if s.get("slug") == "log"), None)

    if log_section is not None:
        log_section["content"] = (log_section.get("content") or "").rstrip() + entry_block
        note = set_daily_note_sections(note=note, sections=sections, template=note.template)
    else:
        # Append to the document tail.
        note.markdown = (note.markdown or "").rstrip() + entry_block
        note.save(update_fields=["markdown", "updated_at"])

    return note


def upsert_default_daily_note(*, tenant, note_date: date) -> DailyNote:
    note, _ = DailyNote.objects.get_or_create(tenant=tenant, date=note_date)
    if note.template_id is None:
        template = get_default_template(tenant=tenant)
        if template is None:
            template = seed_default_templates_for_tenant(tenant=tenant)["template"]
        note.template = template
        if not note.markdown:
            note.markdown = materialize_sections_markdown(
                note_date=note.date,
                sections=_default_template_payload(),
                template_name=template.name if template is not None else None,
            )
            note.save(update_fields=["template", "markdown", "updated_at"])
        else:
            note.save(update_fields=["template", "updated_at"])
    return note
